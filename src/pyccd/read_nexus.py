"""
This module reads nexus tree files that are created by BEAST2.
The function read_nexus_trees() has options to make it compatible with trees
that were generated by the BREATH package and read transmission trees.
"""
import re
from collections import defaultdict

from pyccd.label_transmission_history import label_transmission_tree
from pyccd.tree import Tree


def read_nexus_trees(file: str, breath_trees: bool = True,
                     label_transm_history: bool = True,
                     parse_taxon_map: bool = False) \
        -> list[Tree] | tuple[list[Tree], dict[str, str]]:
    """
    Function to read a nexus file that contains transmission trees.
    This assumes that trees are generated by BREATH BEAST2 package.
    The necessary information is the blockcount for every node/edge.
    This function will fully label the transmission history onto the tree.

    By setting breath_trees to false the transmission history labeling is
    also disabled.

    :param file: Input file
    :param breath_trees: If true, will assume that the trees have the blockcount annotated (default)
    :param label_transm_history: If true, will label transmission ancestry (default)
    :returns: list of transmission trees
    """
    # re_tree returns nwk string without the root height and no ; in the end
    re_tree = re.compile("\t?tree .*=? (.*$)", flags=re.I | re.MULTILINE)
    re_begin_map = re.compile('\t?translate\n', re.I)
    re_end_map = re.compile('\t*?;\n?')
    # name_dict = get_mapping_dict(file)  # Save tree label names in dict

    begin_taxon_map = False
    taxon_map = {}
    trees = []

    with open(file, 'r', encoding="utf-8") as f:
        for line in f:
            if parse_taxon_map:
                if begin_taxon_map:
                    if re_end_map.match(line):
                        begin_taxon_map = False
                        continue
                    split = line.split()
                    taxon_map[int(split[0])] = split[1][:-1] if split[1][-1] == "," else split[1]

                if re_begin_map.match(line):
                    begin_taxon_map = True

            if re_tree.match(line):
                # tree_string = f'{re.split(re_tree, line)[1][:re.split(re_tree, line)[1]
                #                                              .rfind(")") + 1]};'
                tree_string = re.split(re_tree, line)[1]
                meta_data_pattern = r"\d*\[[^\]]*\]"  # matches meta data annotations
                meta_data_brackets = re.compile(r'\[[^\]]*\]')

                counter = 0  # Initialize a counter

                node_meta_data = defaultdict(dict)

                def extract_meta_data_from_match(match):
                    nonlocal counter
                    nonlocal node_meta_data

                    full_str = match.group(0)
                    split_str = full_str.split("[", 1)
                    if not split_str[0]:
                        counter += 1
                    taxa = split_str[0] or f"internal{counter}"

                    metadata_items = split_str[1].rstrip("]").split(",")
                    for item in metadata_items:
                        clean_item, value = item.split("=", 1)
                        clean_item = clean_item.lstrip("&").strip()
                        # NOTE that this assumes . is not present in the actual meta label!
                        clean_item = clean_item.split(".")[0]
                        node_meta_data[taxa][clean_item] = value
                    return taxa

                # Replace all matches, name internal nodes and extract meta data
                sanitized_tree_newick = re.sub(
                    meta_data_pattern,
                    extract_meta_data_from_match,
                    tree_string
                )
                tree = Tree(sanitized_tree_newick, format=1)

                # todo could be labelling trees with metadata by default now...
                if breath_trees:
                    # adjusting the tree to contain the blockcount label and correct node names
                    _breath_label_nodes(tree, node_meta_data)

                trees.append(tree)
    # if only label_transm_history is set to true this won't make sense anyway
    if breath_trees and label_transm_history:
        for tree in trees:
            label_transmission_tree(tree)

    if parse_taxon_map:
        return trees, taxon_map
    return trees


def _cast_to_int(value):
    """
    Custom function to cast a value to an integer. Fallbacks are either float or the original value.
    :param value: Input value to cast
    :return: Integer value or float or original value
    """
    try:
        f = float(value)
        if f.is_integer():
            return int(f)
        return f
    except ValueError:
        return value


def _breath_label_nodes(tree: Tree, node_meta_data) -> None:
    """
    Annotating the node names and blockcount values to an ete3.Tree.
    This only works if the nodes names follow the name convention from above.
    That is %Node-label/blockcount% which is extracted in replace_match() above.

    :param tree: Tree that will get blockcount annotations from node names
    """
    # cast attributes to a specific type of value, should be user definable in the future...
    cast_map = {
        "blockcount": _cast_to_int,
        "blockstart": float,
        "blockend": float,
    }

    for node in tree.traverse("levelorder"):
        # this should technically never be the case...
        if node.name in node_meta_data:
            # Assert node.name format
            for meta_attr, meta_value in node_meta_data[node.name].items():
                caster = cast_map.get(meta_attr, str)
                try:
                    casted_value = caster(meta_value)
                except ValueError:
                    casted_value = meta_value
                node.add_feature(meta_attr, casted_value)
